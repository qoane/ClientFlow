<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ClientFlow – Survey Designer</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #121936;
            --panel2: #0f1530;
            --muted: #9fb0ff;
            --text: #eef1ff;
            --accent: #6cf0c2;
            --accent2: #89b4ff;
            --danger: #ff6b6b;
            --border: rgba(255,255,255,.08);
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 800px at 80% -10%, #1b2550 0%, transparent 60%), var(--bg);
            color: var(--text);
            font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto;
        }

        .app {
            display: grid;
            grid-template-rows: 72px 1fr;
            min-height: 100vh;
        }

        header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg,#141c3f,#0e1533);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .logo {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: conic-gradient(from 210deg, var(--accent), var(--accent2));
            box-shadow: 0 0 0 2px rgba(255,255,255,.07) inset;
        }

        .tag {
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            color: #b9c6ff;
            font-size: 12px;
        }

        .toolbar {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .field label {
            font-size: 12px;
            color: var(--muted);
        }

        input, textarea, select {
            background: var(--panel2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            color: var(--text);
            font: inherit;
        }

        input:focus, textarea:focus, select:focus {
            outline: 2px solid rgba(108,240,194,.4);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: linear-gradient(180deg,#1a2248,#141c3f);
            color: #e9eeff;
            cursor: pointer;
            user-select: none;
            transition: transform .12s ease;
        }

        .btn:hover { transform: translateY(-1px); }
        .btn:disabled { opacity: .6; cursor: not-allowed; }
        .btn.ghost { background: transparent; }
        .btn.accent {
            background: linear-gradient(180deg,#19cba0,#0dbb93);
            color: #031b15;
            border: none;
        }
        .btn.danger {
            background: linear-gradient(180deg,#ef4444,#dc2626);
            color: #fff;
            border: none;
        }

        .shell {
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            gap: 14px;
            padding: 16px;
        }

        @media (max-width:1180px) {
            .shell {
                grid-template-columns: 220px 1fr;
                grid-template-areas:
                    "left main"
                    "left side";
            }
            .properties {
                grid-column: 1 / -1;
            }
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,.18);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel .head {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .panel .body {
            padding: 14px 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .tools {
            display: grid;
            gap: 10px;
        }

        .tool {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            background: linear-gradient(180deg,#1a2248,#141c3f);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .tool strong { font-size: 14px; }
        .tool small { color: rgba(203,214,255,.8); font-size: 12px; }

        .canvas {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .preview {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .preview-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid rgba(255,255,255,.08);
            border-radius: 12px;
            padding: 14px 16px;
            background: var(--panel2);
        }

        .preview-section h3 {
            margin: 0;
            font-size: 15px;
        }

        .preview-section small {
            color: var(--muted);
        }

        .preview-questions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .preview-question {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-radius: 10px;
            padding: 10px 12px;
            background: rgba(9,13,30,.45);
            border: 1px solid rgba(255,255,255,.05);
        }

        .preview-question label {
            font-weight: 600;
        }

        .preview-static {
            background: rgba(9,13,30,.25);
            border-style: dashed;
        }

        .preview-choice-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
        }

        .preview-choice-list label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 400;
        }

        .preview-rating {
            display: inline-flex;
            gap: 4px;
            color: var(--accent2);
            font-size: 18px;
        }

        .preview-matrix {
            width: 100%;
            border-collapse: collapse;
        }

        .preview-matrix th,
        .preview-matrix td {
            border: 1px solid rgba(255,255,255,.08);
            padding: 6px 8px;
            font-size: 13px;
        }

        .preview-divider {
            border: 0;
            border-top: 1px solid rgba(255,255,255,.25);
            margin: 6px 0;
        }

        .preview-spacer {
            width: 100%;
            background: rgba(255,255,255,.04);
            border-radius: 8px;
        }

        .preview-empty {
            text-align: center;
            color: var(--muted);
            padding: 20px 0;
        }

        .canvas-section {
            background: var(--panel);
            border: 1px solid rgba(255,255,255,.06);
            border-radius: 14px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,.15);
        }

        .canvas-section.selected {
            border-color: rgba(108,240,194,.6);
            box-shadow: 0 0 0 2px rgba(108,240,194,.25);
        }

        .section-meta {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-meta h3 {
            margin: 0;
            font-size: 16px;
        }

        .section-meta .actions {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }

        .question-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .question-card {
            border: 1px solid rgba(255,255,255,.05);
            border-radius: 12px;
            padding: 10px 12px;
            background: var(--panel2);
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            cursor: grab;
        }

        .question-card.selected {
            border-color: rgba(108,240,194,.6);
            box-shadow: 0 0 0 2px rgba(108,240,194,.25);
        }

        .question-card small { color: var(--muted); font-size: 12px; }

        .question-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .drop-slot {
            height: 10px;
            border-radius: 6px;
            border: 1px dashed transparent;
        }

        .drop-slot.active {
            border-color: rgba(108,240,194,.6);
            background: rgba(108,240,194,.18);
        }

        .properties .body label {
            font-size: 12px;
            color: var(--muted);
        }

        .properties .body .row {
            display: grid;
            gap: 6px;
        }

        .properties textarea {
            min-height: 90px;
            resize: vertical;
        }

        .switch {
            position: relative;
            width: 40px;
            height: 22px;
            display: inline-block;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,.2);
            transition: .2s;
            border-radius: 999px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            top: 3px;
            background: #0b1020;
            transition: .2s;
            border-radius: 50%;
        }
        .switch input:checked + .slider {
            background: rgba(108,240,194,.6);
        }
        .switch input:checked + .slider:before {
            transform: translateX(16px);
        }

        pre {
            background: var(--panel2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            color: #cfe0ff;
            overflow: auto;
            max-height: 260px;
        }

        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(15,21,48,.95);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,.35);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .toast.error {
            border-color: rgba(255,107,107,.5);
            color: #ffbaba;
        }

        .empty-state {
            padding: 40px 0;
            text-align: center;
            color: var(--muted);
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="brand">
                <div class="logo"></div>
                ClientFlow — <span>Survey Designer</span>
                <span class="tag">Drag &amp; Drop</span>
            </div>
            <div class="field">
                <label for="surveyCode">Survey Code</label>
                <input id="surveyCode" placeholder="liberty-nps" spellcheck="false" />
            </div>
            <div class="field">
                <label for="surveyTitle">Title</label>
                <input id="surveyTitle" placeholder="Liberty NPS 2025" />
            </div>
            <div class="toolbar">
                <button class="btn ghost" id="btnImport">Import JSON</button>
                <button class="btn" id="btnDownload">Download JSON</button>
                <button class="btn accent" id="btnExport">Save to API</button>
            </div>
        </header>

        <div class="shell">
            <aside class="panel" aria-label="Toolbox">
                <div class="head"><strong>Question Types</strong></div>
                <div class="body tools" id="toolbox"></div>
            </aside>

            <main class="canvas" id="canvas">
                <div class="panel" style="padding:0">
                    <div class="head" style="justify-content:space-between">
                        <div style="display:flex;align-items:center;gap:10px">
                            <strong>Survey Flow</strong>
                            <span class="tag" id="sectionCount">0 sections</span>
                        </div>
                        <button class="btn" id="btnAddSection">Add Section</button>
                    </div>
                    <div class="body" id="canvasSections"></div>
                </div>

                <div class="panel">
                    <div class="head"><strong>Live Preview</strong></div>
                    <div class="body">
                        <form id="previewForm" class="preview" aria-label="Survey preview"></form>
                    </div>
                </div>

                <div class="panel">
                    <div class="head" style="justify-content:space-between">
                        <strong>Normalized JSON</strong>
                        <button class="btn ghost" id="btnCopyJson">Copy</button>
                    </div>
                    <div class="body">
                        <pre id="jsonOutput">{}</pre>
                    </div>
                </div>
            </main>

            <aside class="panel properties" aria-label="Properties">
                <div class="head"><strong>Properties</strong></div>
                <div class="body" id="properties"></div>
            </aside>
        </div>
    </div>

    <script src="../app-base.js"></script>
    <script type="module">
        import { SurveyDesignerStore } from './survey-designer-store.js';

        const store = new SurveyDesignerStore();
        const token = localStorage.getItem('authToken');
        if (!token) {
            window.location.href = appBuildUrl('login.html');
        }
        const authHeaders = token ? { 'Authorization': 'Bearer ' + token } : {};
        const toolbox = document.getElementById('toolbox');
        const canvasSections = document.getElementById('canvasSections');
        const sectionCount = document.getElementById('sectionCount');
        const properties = document.getElementById('properties');
        const jsonOutput = document.getElementById('jsonOutput');
        const previewForm = document.getElementById('previewForm');
        const surveyCodeInput = document.getElementById('surveyCode');
        const surveyTitleInput = document.getElementById('surveyTitle');

        let selectedSectionId = null;
        let selectedQuestionId = null;
        let draggingQuestionId = null;

        const palette = [
            { type: 'nps', label: 'NPS 0–10', hint: 'Detractors to promoters scale' },
            { type: 'likert', label: 'Likert 1–5', hint: 'Agreement scale' },
            { type: 'single', label: 'Single Select', hint: 'Radio buttons' },
            { type: 'multi', label: 'Multi Select', hint: 'Checkbox list' },
            { type: 'text', label: 'Free Text', hint: 'Short answer' },
            { type: 'phone', label: 'Phone', hint: '+266 …' },
            { type: 'number', label: 'Numeric', hint: 'Quantitative input' },
            { type: 'date', label: 'Date', hint: 'Calendar picker' },
            { type: 'boolean', label: 'Yes / No', hint: 'Binary choice' },
            { type: 'static_text', label: 'Static Text', hint: 'Display-only paragraph' },
            { type: 'static_html', label: 'Static HTML', hint: 'Raw HTML fragment' },
            { type: 'image', label: 'Image', hint: 'Illustrations or logos' },
            { type: 'video', label: 'Video', hint: 'Embedded media' },
            { type: 'divider', label: 'Divider', hint: 'Section separator' },
            { type: 'spacer', label: 'Spacer', hint: 'Add vertical space' },
            { type: 'matrix', label: 'Matrix', hint: 'Rows × columns grid' },
            { type: 'file', label: 'File Upload', hint: 'Collect attachments' },
            { type: 'signature', label: 'Signature', hint: 'Capture drawn signature' },
            { type: 'rating_stars', label: 'Rating (Stars)', hint: '1–N star rating' }
        ];

        const paletteLabelMap = new Map(palette.map(tool => [tool.type, tool.label]));

        function toast(message, isError = false) {
            const node = document.createElement('div');
            node.className = 'toast' + (isError ? ' error' : '');
            node.textContent = message;
            document.body.appendChild(node);
            setTimeout(() => node.remove(), 2600);
        }

        function createTempId() {
            if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
                return crypto.randomUUID();
            }
            return Math.random().toString(36).slice(2);
        }

        function describeQuestion(question) {
            const settings = question.settings || {};
            switch (question.type) {
                case 'static_text':
                    return (settings.text || '').toString().trim() || 'Static text block';
                case 'static_html': {
                    const html = (settings.html || '').toString();
                    const plain = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                    return plain || 'Static HTML';
                }
                case 'image':
                    return settings.caption || settings.alt || settings.url || 'Image';
                case 'video':
                    return settings.caption || settings.url || 'Video';
                case 'divider':
                    return 'Divider';
                case 'spacer':
                    return 'Spacer';
                case 'matrix':
                    return question.prompt || 'Matrix';
                case 'file':
                    return question.prompt || 'File upload';
                case 'signature':
                    return question.prompt || 'Signature';
                case 'rating_stars':
                    return question.prompt || 'Star rating';
                default:
                    return question.prompt || 'Untitled question';
            }
        }

        function ensureSelection(state) {
            if (!state.sections.some(sec => sec.id === selectedSectionId)) {
                selectedSectionId = state.sections[0]?.id ?? null;
            }
            if (!state.questions.some(q => q.id === selectedQuestionId)) {
                selectedQuestionId = null;
            }
        }

        function renderToolbox() {
            toolbox.innerHTML = '';
            palette.forEach(tool => {
                const card = document.createElement('div');
                card.className = 'tool';
                card.innerHTML = `<strong>${tool.label}</strong><small>${tool.hint}</small>`;
                card.onclick = () => addQuestion(tool.type);
                toolbox.appendChild(card);
            });
        }

        function addQuestion(type) {
            const state = store.getState();
            let targetSection = selectedSectionId;
            if (!targetSection) {
                const first = state.sections[0];
                if (first) {
                    targetSection = first.id;
                } else {
                    targetSection = store.addSection('Section 1').id;
                }
            }
            const question = store.addQuestion(targetSection, type);
            selectedSectionId = targetSection;
            selectedQuestionId = question.id;
        }

        function renderCanvas(state) {
            sectionCount.textContent = `${state.sections.length} section${state.sections.length === 1 ? '' : 's'}`;
            canvasSections.innerHTML = '';
            if (state.sections.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.innerHTML = 'No sections yet. Add one to start designing.';
                canvasSections.appendChild(empty);
                return;
            }

            state.sections.forEach((section, sectionIndex) => {
                const secEl = document.createElement('div');
                secEl.className = 'canvas-section';
                secEl.dataset.sectionId = section.id;
                if (section.id === selectedSectionId) secEl.classList.add('selected');
                secEl.onclick = (ev) => {
                    if (ev.target.closest('button')) return;
                    selectedSectionId = section.id;
                    selectedQuestionId = null;
                    renderProperties(store.getState());
                    highlightSelection();
                };

                const meta = document.createElement('div');
                meta.className = 'section-meta';

                const titleInput = document.createElement('input');
                titleInput.value = section.title;
                titleInput.onchange = () => store.updateSection(section.id, { title: titleInput.value });
                titleInput.onfocus = () => { selectedSectionId = section.id; highlightSelection(); };
                titleInput.style.minWidth = '180px';
                meta.appendChild(titleInput);

                const sectionLabel = document.createElement('span');
                sectionLabel.className = 'tag';
                sectionLabel.textContent = `Order ${section.order}`;
                meta.appendChild(sectionLabel);

                const actions = document.createElement('div');
                actions.className = 'actions';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn ghost';
                removeBtn.textContent = 'Delete';
                removeBtn.onclick = (ev) => {
                    ev.stopPropagation();
                    if (!confirm('Delete this section? Questions will be removed.')) return;
                    store.deleteSection(section.id);
                };
                actions.appendChild(removeBtn);

                if (sectionIndex > 0) {
                    const upBtn = document.createElement('button');
                    upBtn.className = 'btn ghost';
                    upBtn.textContent = '↑';
                    upBtn.onclick = (ev) => { ev.stopPropagation(); store.moveSection(section.id, sectionIndex - 1); };
                    actions.appendChild(upBtn);
                }
                if (sectionIndex < state.sections.length - 1) {
                    const downBtn = document.createElement('button');
                    downBtn.className = 'btn ghost';
                    downBtn.textContent = '↓';
                    downBtn.onclick = (ev) => { ev.stopPropagation(); store.moveSection(section.id, sectionIndex + 1); };
                    actions.appendChild(downBtn);
                }

                meta.appendChild(actions);
                secEl.appendChild(meta);

                const list = document.createElement('div');
                list.className = 'question-list';
                list.dataset.sectionId = section.id;

                const questions = state.questions
                    .filter(q => (q.sectionId ?? null) === section.id)
                    .sort((a, b) => a.order - b.order);

                for (let i = 0; i <= questions.length; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'drop-slot';
                    drop.dataset.index = i;
                    drop.addEventListener('dragover', ev => { ev.preventDefault(); drop.classList.add('active'); });
                    drop.addEventListener('dragleave', () => drop.classList.remove('active'));
                    drop.addEventListener('drop', ev => {
                        ev.preventDefault();
                        drop.classList.remove('active');
                        if (draggingQuestionId) {
                            store.moveQuestion(draggingQuestionId, section.id, Number(drop.dataset.index));
                        }
                    });
                    list.appendChild(drop);

                    if (i < questions.length) {
                        const question = questions[i];
                        const card = document.createElement('div');
                        card.className = 'question-card';
                        card.dataset.questionId = question.id;
                        card.draggable = true;
                        if (question.id === selectedQuestionId) card.classList.add('selected');
                        card.addEventListener('dragstart', () => { draggingQuestionId = question.id; });
                        card.addEventListener('dragend', () => { draggingQuestionId = null; });
                        card.onclick = (ev) => {
                            if (ev.target.closest('button')) return;
                            selectedQuestionId = question.id;
                            selectedSectionId = section.id;
                            renderProperties(store.getState());
                            highlightSelection();
                        };

                        const info = document.createElement('div');
                        const title = document.createElement('div');
                        title.textContent = describeQuestion(question);
                        const metaLine = document.createElement('small');
                        const paletteLabel = paletteLabelMap.get(question.type) || question.type.toUpperCase();
                        metaLine.textContent = `${paletteLabel} • ${question.key}`;
                        info.appendChild(title);
                        info.appendChild(metaLine);

                        const qActions = document.createElement('div');
                        qActions.className = 'question-actions';
                        const reqTag = document.createElement('span');
                        reqTag.className = 'tag';
                        reqTag.textContent = question.required ? 'Required' : 'Optional';
                        reqTag.style.background = question.required ? 'rgba(108,240,194,.12)' : 'rgba(159,176,255,.12)';
                        qActions.appendChild(reqTag);

                        const delBtn = document.createElement('button');
                        delBtn.className = 'btn ghost';
                        delBtn.textContent = 'Delete';
                        delBtn.onclick = (ev) => { ev.stopPropagation(); store.deleteQuestion(question.id); };
                        qActions.appendChild(delBtn);

                        card.appendChild(info);
                        card.appendChild(qActions);
                        list.appendChild(card);
                    }
                }

                const addAnother = document.createElement('button');
                addAnother.className = 'btn ghost';
                addAnother.textContent = 'Add question here';
                addAnother.onclick = (ev) => { ev.stopPropagation(); selectedSectionId = section.id; addQuestion('text'); };
                list.appendChild(addAnother);

                secEl.appendChild(list);
                canvasSections.appendChild(secEl);
            });
        }

        function highlightSelection() {
            document.querySelectorAll('.canvas-section').forEach(section => section.classList.remove('selected'));
            document.querySelectorAll('.question-card').forEach(card => card.classList.remove('selected'));
            if (selectedSectionId) {
                const container = document.querySelector(`.canvas-section[data-section-id="${selectedSectionId}"]`);
                if (container) container.classList.add('selected');
            }
            if (selectedQuestionId) {
                const card = document.querySelector(`.question-card[data-question-id="${selectedQuestionId}"]`);
                if (card) card.classList.add('selected');
            }
        }

        function renderProperties(state) {
            properties.innerHTML = '';
            if (!selectedQuestionId) {
                const hint = document.createElement('div');
                hint.className = 'empty-state';
                hint.innerHTML = 'Select a question to edit its properties.';
                properties.appendChild(hint);
                return;
            }

            const question = state.questions.find(q => q.id === selectedQuestionId);
            if (!question) {
                selectedQuestionId = null;
                renderProperties(state);
                return;
            }

            const settings = question.settings || {};

            const makeRow = (label, control) => {
                const row = document.createElement('div');
                row.className = 'row';
                const lab = document.createElement('label');
                lab.textContent = label;
                row.appendChild(lab);
                row.appendChild(control);
                return row;
            };

            const getLatestQuestion = () => store.getState().questions.find(q => q.id === question.id) ?? question;

            const updateSettings = (producer) => {
                const latest = getLatestQuestion();
                const base = { ...(latest.settings ?? {}) };
                const next = producer(base) ?? base;
                store.updateQuestion(question.id, { settings: next });
            };

            const setSettingValue = (key, value, removeEmpty = false) => {
                updateSettings(current => {
                    const next = { ...current };
                    const shouldRemove = removeEmpty && (value === '' || value === null || value === undefined || (typeof value === 'number' && !Number.isFinite(value)));
                    if (shouldRemove) {
                        delete next[key];
                    } else {
                        next[key] = value;
                    }
                    return next;
                });
            };

            const isStatic = question.type.startsWith('static_');
            const isLayoutOnly = ['divider', 'spacer'].includes(question.type);
            const isMedia = ['image', 'video'].includes(question.type);
            const showPrompt = !['static_text', 'static_html', 'divider', 'spacer'].includes(question.type);
            const allowRequired = !isStatic && !isLayoutOnly && !isMedia;
            const showValidations = !isStatic && !isLayoutOnly && !isMedia;
            const showChoices = ['nps', 'likert', 'single', 'multi', 'boolean'].includes(question.type);

            if (showPrompt) {
                const promptInput = document.createElement('textarea');
                promptInput.value = question.prompt;
                promptInput.oninput = () => store.updateQuestion(question.id, { prompt: promptInput.value });
                properties.appendChild(makeRow('Prompt', promptInput));
            }

            const keyInput = document.createElement('input');
            keyInput.value = question.key;
            keyInput.onchange = () => store.updateQuestion(question.id, { key: keyInput.value.trim() });
            properties.appendChild(makeRow('Key', keyInput));

            const requiredToggle = document.createElement('label');
            requiredToggle.className = 'switch';
            const reqInput = document.createElement('input');
            reqInput.type = 'checkbox';
            reqInput.checked = allowRequired ? !!question.required : false;
            reqInput.disabled = !allowRequired;
            reqInput.onchange = () => store.updateQuestion(question.id, { required: reqInput.checked });
            const slider = document.createElement('span');
            slider.className = 'slider';
            requiredToggle.appendChild(reqInput);
            requiredToggle.appendChild(slider);
            properties.appendChild(makeRow('Required', requiredToggle));

            if (showChoices) {
                const choicesArea = document.createElement('textarea');
                choicesArea.placeholder = 'value|Label';
                choicesArea.value = question.choices.map(choice => `${choice.value}|${choice.label}`).join('\n');
                choicesArea.onchange = () => {
                    const latest = getLatestQuestion();
                    const lines = choicesArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                    const mapped = lines.map((line, idx) => {
                        const [valuePart, labelPart] = line.includes('|') ? line.split('|') : [line, line];
                        const value = (valuePart || '').trim();
                        const label = (labelPart || valuePart || '').trim();
                        const existing = latest?.choices?.[idx];
                        return {
                            id: existing?.id ?? createTempId(),
                            value: value || label || `choice_${idx + 1}`,
                            label: label || value || `Choice ${idx + 1}`
                        };
                    });
                    store.updateQuestion(question.id, { choices: mapped });
                };
                properties.appendChild(makeRow('Choices', choicesArea));
            }

            switch (question.type) {
                case 'static_text': {
                    const textArea = document.createElement('textarea');
                    textArea.style.minHeight = '140px';
                    textArea.placeholder = 'Display text';
                    textArea.value = settings.text || '';
                    textArea.oninput = () => setSettingValue('text', textArea.value, true);
                    properties.appendChild(makeRow('Text', textArea));

                    const alignSelect = document.createElement('select');
                    [
                        { value: '', label: 'Automatic' },
                        { value: 'left', label: 'Left' },
                        { value: 'center', label: 'Center' },
                        { value: 'right', label: 'Right' },
                        { value: 'justify', label: 'Justify' }
                    ].forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        alignSelect.appendChild(option);
                    });
                    alignSelect.value = settings.alignment ?? '';
                    alignSelect.onchange = () => setSettingValue('alignment', alignSelect.value, true);
                    properties.appendChild(makeRow('Alignment', alignSelect));
                    break;
                }
                case 'static_html': {
                    const htmlArea = document.createElement('textarea');
                    htmlArea.style.minHeight = '180px';
                    htmlArea.placeholder = '<p>Welcome!</p>';
                    htmlArea.value = settings.html || '';
                    htmlArea.oninput = () => setSettingValue('html', htmlArea.value, true);
                    properties.appendChild(makeRow('HTML', htmlArea));

                    const cssArea = document.createElement('textarea');
                    cssArea.placeholder = '.wrapper { color: #fff; }';
                    cssArea.value = settings.scopedCss || '';
                    cssArea.onchange = () => setSettingValue('scopedCss', cssArea.value.trim(), true);
                    properties.appendChild(makeRow('Scoped CSS', cssArea));
                    break;
                }
                case 'image': {
                    const urlInput = document.createElement('input');
                    urlInput.placeholder = 'https://example.com/image.png';
                    urlInput.value = settings.url || '';
                    urlInput.onchange = () => setSettingValue('url', urlInput.value.trim(), true);
                    properties.appendChild(makeRow('Image URL', urlInput));

                    const altInput = document.createElement('input');
                    altInput.placeholder = 'Accessible alt text';
                    altInput.value = settings.alt || '';
                    altInput.onchange = () => setSettingValue('alt', altInput.value.trim(), true);
                    properties.appendChild(makeRow('Alt Text', altInput));

                    const captionInput = document.createElement('input');
                    captionInput.placeholder = 'Caption';
                    captionInput.value = settings.caption || '';
                    captionInput.onchange = () => setSettingValue('caption', captionInput.value.trim(), true);
                    properties.appendChild(makeRow('Caption', captionInput));

                    const widthInput = document.createElement('input');
                    widthInput.placeholder = 'Width (e.g. 320px or 100%)';
                    widthInput.value = settings.width || '';
                    widthInput.onchange = () => setSettingValue('width', widthInput.value.trim(), true);
                    properties.appendChild(makeRow('Width', widthInput));

                    const heightInput = document.createElement('input');
                    heightInput.placeholder = 'Height (optional)';
                    heightInput.value = settings.height || '';
                    heightInput.onchange = () => setSettingValue('height', heightInput.value.trim(), true);
                    properties.appendChild(makeRow('Height', heightInput));
                    break;
                }
                case 'video': {
                    const urlInput = document.createElement('input');
                    urlInput.placeholder = 'https://player.vimeo.com/...';
                    urlInput.value = settings.url || '';
                    urlInput.onchange = () => setSettingValue('url', urlInput.value.trim(), true);
                    properties.appendChild(makeRow('Video URL', urlInput));

                    const posterInput = document.createElement('input');
                    posterInput.placeholder = 'Poster image URL';
                    posterInput.value = settings.poster || '';
                    posterInput.onchange = () => setSettingValue('poster', posterInput.value.trim(), true);
                    properties.appendChild(makeRow('Poster', posterInput));

                    const captionInput = document.createElement('input');
                    captionInput.placeholder = 'Caption';
                    captionInput.value = settings.caption || '';
                    captionInput.onchange = () => setSettingValue('caption', captionInput.value.trim(), true);
                    properties.appendChild(makeRow('Caption', captionInput));

                    const autoplayToggle = document.createElement('label');
                    autoplayToggle.className = 'switch';
                    const autoplayInput = document.createElement('input');
                    autoplayInput.type = 'checkbox';
                    autoplayInput.checked = !!settings.autoplay;
                    autoplayInput.onchange = () => updateSettings(current => {
                        const next = { ...current };
                        if (autoplayInput.checked) next.autoplay = true;
                        else delete next.autoplay;
                        return next;
                    });
                    const autoplaySlider = document.createElement('span');
                    autoplaySlider.className = 'slider';
                    autoplayToggle.appendChild(autoplayInput);
                    autoplayToggle.appendChild(autoplaySlider);
                    properties.appendChild(makeRow('Autoplay', autoplayToggle));

                    const loopToggle = document.createElement('label');
                    loopToggle.className = 'switch';
                    const loopInput = document.createElement('input');
                    loopInput.type = 'checkbox';
                    loopInput.checked = !!settings.loop;
                    loopInput.onchange = () => updateSettings(current => {
                        const next = { ...current };
                        if (loopInput.checked) next.loop = true;
                        else delete next.loop;
                        return next;
                    });
                    const loopSlider = document.createElement('span');
                    loopSlider.className = 'slider';
                    loopToggle.appendChild(loopInput);
                    loopToggle.appendChild(loopSlider);
                    properties.appendChild(makeRow('Loop', loopToggle));
                    break;
                }
                case 'divider': {
                    const styleSelect = document.createElement('select');
                    [
                        { value: 'solid', label: 'Solid' },
                        { value: 'dashed', label: 'Dashed' },
                        { value: 'dotted', label: 'Dotted' },
                        { value: 'double', label: 'Double' }
                    ].forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        styleSelect.appendChild(option);
                    });
                    styleSelect.value = settings.style || 'solid';
                    styleSelect.onchange = () => setSettingValue('style', styleSelect.value || 'solid');
                    properties.appendChild(makeRow('Style', styleSelect));

                    const colorInput = document.createElement('input');
                    colorInput.placeholder = '#6cf0c2 or var(--accent)';
                    colorInput.value = settings.color || '';
                    colorInput.onchange = () => setSettingValue('color', colorInput.value.trim(), true);
                    properties.appendChild(makeRow('Color', colorInput));

                    const thicknessInput = document.createElement('input');
                    thicknessInput.type = 'number';
                    thicknessInput.min = '1';
                    thicknessInput.value = settings.thickness ?? 1;
                    thicknessInput.onchange = () => {
                        const value = parseInt(thicknessInput.value, 10);
                        updateSettings(current => {
                            const next = { ...current };
                            if (Number.isFinite(value) && value > 0) next.thickness = value;
                            else delete next.thickness;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Thickness (px)', thicknessInput));
                    break;
                }
                case 'spacer': {
                    const sizeSelect = document.createElement('select');
                    [
                        { value: 'sm', label: 'Small' },
                        { value: 'md', label: 'Medium' },
                        { value: 'lg', label: 'Large' }
                    ].forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        sizeSelect.appendChild(option);
                    });
                    sizeSelect.value = settings.size || 'md';
                    sizeSelect.onchange = () => setSettingValue('size', sizeSelect.value || 'md');
                    properties.appendChild(makeRow('Preset Size', sizeSelect));

                    const heightInput = document.createElement('input');
                    heightInput.type = 'number';
                    heightInput.min = '0';
                    heightInput.placeholder = 'Custom height (px)';
                    heightInput.value = settings.customHeight ?? '';
                    heightInput.onchange = () => {
                        const value = parseInt(heightInput.value, 10);
                        updateSettings(current => {
                            const next = { ...current };
                            if (Number.isFinite(value) && value > 0) next.customHeight = value;
                            else delete next.customHeight;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Custom Height', heightInput));
                    break;
                }
                case 'matrix': {
                    const rowsArea = document.createElement('textarea');
                    rowsArea.placeholder = 'row_id|Row label';
                    rowsArea.value = (settings.rows ?? []).map(row => `${row.id}|${row.label}`).join('\n');
                    rowsArea.onchange = () => {
                        const latest = getLatestQuestion();
                        const existingRows = Array.isArray(latest?.settings?.rows) ? latest.settings.rows : (settings.rows ?? []);
                        const lines = rowsArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                        const rows = lines.length ? lines.map((line, idx) => {
                            const [idPart, labelPart] = line.includes('|') ? line.split('|') : [line, line];
                            const existing = existingRows[idx];
                            const id = (idPart || '').trim() || existing?.id || createTempId();
                            const label = (labelPart || '').trim() || existing?.label || `Row ${idx + 1}`;
                            return { id, label };
                        }) : (existingRows.length ? existingRows : [{ id: createTempId(), label: 'Row 1' }]);
                        updateSettings(current => ({ ...current, rows }));
                    };
                    properties.appendChild(makeRow('Rows', rowsArea));

                    const colsArea = document.createElement('textarea');
                    colsArea.placeholder = 'col_id|Column label|type';
                    colsArea.value = (settings.columns ?? []).map(col => `${col.id}|${col.label}|${col.type ?? ''}`).join('\n');
                    colsArea.onchange = () => {
                        const latest = getLatestQuestion();
                        const existingCols = Array.isArray(latest?.settings?.columns) ? latest.settings.columns : (settings.columns ?? []);
                        const lines = colsArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                        const columns = lines.length ? lines.map((line, idx) => {
                            const parts = line.split('|');
                            const idPart = (parts[0] || '').trim();
                            const labelPart = (parts[1] || '').trim();
                            const typePart = (parts[2] || '').trim();
                            const existing = existingCols[idx];
                            const id = idPart || existing?.id || createTempId();
                            const label = labelPart || existing?.label || `Column ${idx + 1}`;
                            const type = typePart || existing?.type || settings.cellType || 'text';
                            return { id, label, type };
                        }) : (existingCols.length ? existingCols : [{ id: createTempId(), label: 'Column 1', type: settings.cellType || 'text' }]);
                        updateSettings(current => ({ ...current, columns }));
                    };
                    properties.appendChild(makeRow('Columns', colsArea));

                    const cellTypeInput = document.createElement('input');
                    cellTypeInput.placeholder = 'Default cell type (e.g. text, radio)';
                    cellTypeInput.value = settings.cellType || 'text';
                    cellTypeInput.onchange = () => setSettingValue('cellType', cellTypeInput.value.trim(), true);
                    properties.appendChild(makeRow('Default Cell Type', cellTypeInput));
                    break;
                }
                case 'file': {
                    const allowedArea = document.createElement('textarea');
                    allowedArea.placeholder = 'image/*,application/pdf';
                    allowedArea.value = Array.isArray(settings.allowedTypes) ? settings.allowedTypes.join('\n') : '';
                    allowedArea.onchange = () => {
                        const tokens = allowedArea.value.split(/[,\n]/).map(x => x.trim()).filter(Boolean);
                        updateSettings(current => {
                            const next = { ...current };
                            if (tokens.length) next.allowedTypes = tokens;
                            else delete next.allowedTypes;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Allowed Types', allowedArea));

                    const maxSizeInput = document.createElement('input');
                    maxSizeInput.type = 'number';
                    maxSizeInput.min = '0';
                    maxSizeInput.step = '0.5';
                    maxSizeInput.placeholder = 'Max size (MB)';
                    maxSizeInput.value = settings.maxFileSize ? (settings.maxFileSize / (1024 * 1024)).toFixed(1).replace(/\.0$/, '') : '';
                    maxSizeInput.onchange = () => {
                        const value = parseFloat(maxSizeInput.value);
                        updateSettings(current => {
                            const next = { ...current };
                            if (Number.isFinite(value) && value > 0) next.maxFileSize = Math.round(value * 1024 * 1024);
                            else delete next.maxFileSize;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Max File Size (MB)', maxSizeInput));

                    const maxFilesInput = document.createElement('input');
                    maxFilesInput.type = 'number';
                    maxFilesInput.min = '1';
                    maxFilesInput.placeholder = 'Max files';
                    maxFilesInput.value = settings.maxFiles ?? '';
                    maxFilesInput.onchange = () => {
                        const value = parseInt(maxFilesInput.value, 10);
                        updateSettings(current => {
                            const next = { ...current };
                            if (Number.isFinite(value) && value > 0) next.maxFiles = value;
                            else delete next.maxFiles;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Max Files', maxFilesInput));
                    break;
                }
                case 'signature': {
                    const bgInput = document.createElement('input');
                    bgInput.placeholder = '#ffffff';
                    bgInput.value = settings.backgroundColor || '';
                    bgInput.onchange = () => setSettingValue('backgroundColor', bgInput.value.trim(), true);
                    properties.appendChild(makeRow('Background Color', bgInput));

                    const penInput = document.createElement('input');
                    penInput.placeholder = '#000000';
                    penInput.value = settings.penColor || '';
                    penInput.onchange = () => setSettingValue('penColor', penInput.value.trim(), true);
                    properties.appendChild(makeRow('Pen Color', penInput));

                    const guideToggle = document.createElement('label');
                    guideToggle.className = 'switch';
                    const guideInput = document.createElement('input');
                    guideInput.type = 'checkbox';
                    guideInput.checked = settings.showGuideline !== false;
                    guideInput.onchange = () => updateSettings(current => {
                        const next = { ...current };
                        next.showGuideline = guideInput.checked;
                        return next;
                    });
                    const guideSlider = document.createElement('span');
                    guideSlider.className = 'slider';
                    guideToggle.appendChild(guideInput);
                    guideToggle.appendChild(guideSlider);
                    properties.appendChild(makeRow('Show Guideline', guideToggle));
                    break;
                }
                case 'rating_stars': {
                    const starsInput = document.createElement('input');
                    starsInput.type = 'number';
                    starsInput.min = '1';
                    starsInput.max = '10';
                    starsInput.value = settings.stars ?? 5;
                    starsInput.onchange = () => {
                        const value = parseInt(starsInput.value, 10);
                        updateSettings(current => {
                            const next = { ...current };
                            if (Number.isFinite(value) && value > 0) next.stars = value;
                            else delete next.stars;
                            return next;
                        });
                    };
                    properties.appendChild(makeRow('Stars', starsInput));

                    const iconInput = document.createElement('input');
                    iconInput.placeholder = 'Icon name';
                    iconInput.value = settings.icon || 'star';
                    iconInput.onchange = () => setSettingValue('icon', iconInput.value.trim(), true);
                    properties.appendChild(makeRow('Icon', iconInput));

                    const labelsToggle = document.createElement('label');
                    labelsToggle.className = 'switch';
                    const labelsInput = document.createElement('input');
                    labelsInput.type = 'checkbox';
                    labelsInput.checked = !!settings.showLabels;
                    labelsInput.onchange = () => updateSettings(current => {
                        const next = { ...current };
                        if (labelsInput.checked) next.showLabels = true;
                        else delete next.showLabels;
                        return next;
                    });
                    const labelsSlider = document.createElement('span');
                    labelsSlider.className = 'slider';
                    labelsToggle.appendChild(labelsInput);
                    labelsToggle.appendChild(labelsSlider);
                    properties.appendChild(makeRow('Show Labels', labelsToggle));
                    break;
                }
                default:
                    break;
            }

            if (showValidations) {
                const validationsArea = document.createElement('textarea');
                validationsArea.placeholder = 'One validation per line (e.g. min:1)';
                validationsArea.value = (question.validations || []).join('\n');
                validationsArea.onchange = () => {
                    const items = validationsArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                    store.updateQuestion(question.id, { validations: items });
                };
                properties.appendChild(makeRow('Validations', validationsArea));
            }

            const visibleIfInput = document.createElement('input');
            visibleIfInput.placeholder = "e.g. status = 'active'";
            visibleIfInput.value = question.visibleIf || '';
            visibleIfInput.onchange = () => store.updateQuestion(question.id, { visibleIf: visibleIfInput.value.trim() });
            properties.appendChild(makeRow('Visible If', visibleIfInput));
        }

        function renderPreview(state) {
            if (!previewForm) return;
            previewForm.innerHTML = '';

            const sections = state.sections.slice().sort((a, b) => a.order - b.order);
            const questionsBySection = new Map();
            state.questions.forEach(question => {
                const key = question.sectionId ?? null;
                if (!questionsBySection.has(key)) questionsBySection.set(key, []);
                questionsBySection.get(key).push(question);
            });
            questionsBySection.forEach(list => list.sort((a, b) => a.order - b.order));

            if (sections.length === 0 && !(questionsBySection.get(null)?.length)) {
                const empty = document.createElement('div');
                empty.className = 'preview-empty';
                empty.textContent = 'Add sections to preview the survey.';
                previewForm.appendChild(empty);
                return;
            }

            sections.forEach(section => {
                const sectionEl = document.createElement('div');
                sectionEl.className = 'preview-section';

                const heading = document.createElement('h3');
                heading.textContent = section.title;
                sectionEl.appendChild(heading);

                const questionsEl = document.createElement('div');
                questionsEl.className = 'preview-questions';

                const questions = questionsBySection.get(section.id) ?? [];
                if (questions.length === 0) {
                    const placeholder = document.createElement('small');
                    placeholder.textContent = 'No questions yet.';
                    questionsEl.appendChild(placeholder);
                } else {
                    questions.forEach(question => {
                        questionsEl.appendChild(renderPreviewQuestion(question));
                    });
                }

                sectionEl.appendChild(questionsEl);
                previewForm.appendChild(sectionEl);
            });

            const unassigned = questionsBySection.get(null) ?? [];
            if (unassigned.length > 0) {
                const sectionEl = document.createElement('div');
                sectionEl.className = 'preview-section';

                const heading = document.createElement('h3');
                heading.textContent = 'Ungrouped Questions';
                sectionEl.appendChild(heading);

                const questionsEl = document.createElement('div');
                questionsEl.className = 'preview-questions';
                unassigned.forEach(question => {
                    questionsEl.appendChild(renderPreviewQuestion(question));
                });

                sectionEl.appendChild(questionsEl);
                previewForm.appendChild(sectionEl);
            }
        }

        function renderPreviewQuestion(question) {
            const wrapper = document.createElement('div');
            wrapper.className = 'preview-question';
            const settings = question.settings || {};
            const label = paletteLabelMap.get(question.type) || question.type.toUpperCase();

            switch (question.type) {
                case 'static_text': {
                    wrapper.classList.add('preview-static');
                    const textBlock = document.createElement('p');
                    textBlock.textContent = (settings.text || '').toString() || 'Static text';
                    if (settings.alignment) textBlock.style.textAlign = settings.alignment;
                    wrapper.appendChild(textBlock);
                    break;
                }
                case 'static_html': {
                    wrapper.classList.add('preview-static');
                    const htmlBlock = document.createElement('div');
                    htmlBlock.innerHTML = settings.html || '<em style="color:var(--muted)">Empty HTML</em>';
                    wrapper.appendChild(htmlBlock);
                    break;
                }
                case 'image': {
                    wrapper.classList.add('preview-static');
                    const figure = document.createElement('figure');
                    figure.style.margin = '0';
                    const img = document.createElement('img');
                    img.style.maxWidth = '100%';
                    if (settings.url) {
                        img.src = settings.url;
                    } else {
                        img.alt = 'Image URL not set';
                    }
                    if (settings.alt) img.alt = settings.alt;
                    if (settings.width) img.style.width = settings.width;
                    if (settings.height) img.style.height = settings.height;
                    figure.appendChild(img);
                    if (settings.caption) {
                        const figcaption = document.createElement('figcaption');
                        figcaption.textContent = settings.caption;
                        figcaption.style.fontSize = '12px';
                        figcaption.style.color = 'var(--muted)';
                        figure.appendChild(figcaption);
                    }
                    wrapper.appendChild(figure);
                    break;
                }
                case 'video': {
                    wrapper.classList.add('preview-static');
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    if (settings.poster) video.poster = settings.poster;
                    if (settings.autoplay) video.autoplay = true;
                    if (settings.loop) video.loop = true;
                    if (settings.url) {
                        const source = document.createElement('source');
                        source.src = settings.url;
                        video.appendChild(source);
                    } else {
                        video.innerHTML = '<source />';
                    }
                    wrapper.appendChild(video);
                    if (settings.caption) {
                        const caption = document.createElement('div');
                        caption.textContent = settings.caption;
                        caption.style.fontSize = '12px';
                        caption.style.color = 'var(--muted)';
                        wrapper.appendChild(caption);
                    }
                    break;
                }
                case 'divider': {
                    wrapper.classList.add('preview-static');
                    const hr = document.createElement('hr');
                    hr.className = 'preview-divider';
                    if (settings.color) hr.style.borderTopColor = settings.color;
                    if (settings.thickness) hr.style.borderTopWidth = `${settings.thickness}px`;
                    if (settings.style) hr.style.borderTopStyle = settings.style;
                    wrapper.appendChild(hr);
                    break;
                }
                case 'spacer': {
                    wrapper.classList.add('preview-static');
                    const space = document.createElement('div');
                    space.className = 'preview-spacer';
                    const sizeMap = { sm: 16, md: 28, lg: 44 };
                    const height = settings.customHeight ?? sizeMap[settings.size] ?? 28;
                    space.style.height = `${height}px`;
                    wrapper.appendChild(space);
                    break;
                }
                case 'matrix': {
                    const labelEl = document.createElement('label');
                    labelEl.textContent = question.prompt || label;
                    wrapper.appendChild(labelEl);
                    const table = document.createElement('table');
                    table.className = 'preview-matrix';
                    const header = document.createElement('tr');
                    header.appendChild(document.createElement('th'));
                    (settings.columns ?? []).forEach(col => {
                        const th = document.createElement('th');
                        th.textContent = col.label || col.id;
                        header.appendChild(th);
                    });
                    table.appendChild(header);
                    (settings.rows ?? []).forEach(row => {
                        const tr = document.createElement('tr');
                        const th = document.createElement('th');
                        th.textContent = row.label || row.id;
                        tr.appendChild(th);
                        const columns = settings.columns ?? [];
                        if (columns.length === 0) {
                            const td = document.createElement('td');
                            td.textContent = '—';
                            tr.appendChild(td);
                        } else {
                            columns.forEach(() => {
                                const td = document.createElement('td');
                                td.textContent = '○';
                                tr.appendChild(td);
                            });
                        }
                        table.appendChild(tr);
                    });
                    wrapper.appendChild(table);
                    break;
                }
                case 'file': {
                    const labelEl = document.createElement('label');
                    labelEl.textContent = question.prompt || label;
                    wrapper.appendChild(labelEl);
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.disabled = true;
                    if (Array.isArray(settings.allowedTypes) && settings.allowedTypes.length) {
                        input.accept = settings.allowedTypes.join(',');
                    }
                    if ((settings.maxFiles ?? 1) > 1) input.multiple = true;
                    wrapper.appendChild(input);
                    break;
                }
                case 'signature': {
                    const labelEl = document.createElement('label');
                    labelEl.textContent = question.prompt || label;
                    wrapper.appendChild(labelEl);
                    const pad = document.createElement('div');
                    pad.textContent = 'Signature pad preview';
                    pad.style.border = '1px dashed rgba(255,255,255,.25)';
                    pad.style.borderRadius = '8px';
                    pad.style.height = '120px';
                    pad.style.display = 'flex';
                    pad.style.alignItems = 'center';
                    pad.style.justifyContent = 'center';
                    pad.style.background = settings.backgroundColor || 'rgba(255,255,255,.05)';
                    pad.style.color = settings.penColor || 'var(--muted)';
                    wrapper.appendChild(pad);
                    break;
                }
                case 'rating_stars': {
                    const labelEl = document.createElement('label');
                    labelEl.textContent = question.prompt || label;
                    wrapper.appendChild(labelEl);
                    const rating = document.createElement('div');
                    rating.className = 'preview-rating';
                    const total = settings.stars ?? 5;
                    for (let i = 0; i < total; i++) {
                        const star = document.createElement('span');
                        star.textContent = '★';
                        rating.appendChild(star);
                    }
                    wrapper.appendChild(rating);
                    break;
                }
                default: {
                    const labelEl = document.createElement('label');
                    labelEl.textContent = question.prompt || label;
                    wrapper.appendChild(labelEl);
                    const control = createPreviewControl(question);
                    if (control) wrapper.appendChild(control);
                    break;
                }
            }

            return wrapper;
        }

        function createPreviewControl(question) {
            const controlType = question.type;
            switch (controlType) {
                case 'text': {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.disabled = true;
                    input.placeholder = 'Short answer';
                    return input;
                }
                case 'phone': {
                    const input = document.createElement('input');
                    input.type = 'tel';
                    input.disabled = true;
                    input.placeholder = '+266 …';
                    return input;
                }
                case 'number': {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.disabled = true;
                    return input;
                }
                case 'date': {
                    const input = document.createElement('input');
                    input.type = 'date';
                    input.disabled = true;
                    return input;
                }
                case 'boolean':
                case 'single':
                case 'likert':
                case 'nps': {
                    return createChoiceList(question, 'radio');
                }
                case 'multi': {
                    return createChoiceList(question, 'checkbox');
                }
                default: {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.disabled = true;
                    return input;
                }
            }
        }

        function createChoiceList(question, inputType) {
            const container = document.createElement('div');
            container.className = 'preview-choice-list';
            const choices = question.choices ?? [];
            if (choices.length === 0) {
                const placeholder = document.createElement('span');
                placeholder.style.color = 'var(--muted)';
                placeholder.textContent = 'No options defined';
                container.appendChild(placeholder);
                return container;
            }
            choices.forEach(choice => {
                const item = document.createElement('label');
                const input = document.createElement('input');
                input.type = inputType;
                input.disabled = true;
                if (inputType === 'radio') input.name = question.id;
                if (inputType === 'checkbox') input.name = `${question.id}[]`;
                item.appendChild(input);
                const span = document.createElement('span');
                span.textContent = choice.label || choice.value;
                item.appendChild(span);
                container.appendChild(item);
            });
            return container;
        }

        function renderJson() {
            jsonOutput.textContent = JSON.stringify(store.toJSON(), null, 2);
        }

        renderToolbox();

        store.subscribe(state => {
            ensureSelection(state);
            if (document.activeElement !== surveyTitleInput) surveyTitleInput.value = state.title ?? '';
            if (document.activeElement !== surveyCodeInput) surveyCodeInput.value = state.code ?? '';
            renderCanvas(state);
            renderProperties(state);
            renderPreview(state);
            renderJson();
            highlightSelection();
        });

        document.getElementById('btnAddSection').onclick = () => {
            const section = store.addSection(`Section ${store.getState().sections.length + 1}`);
            selectedSectionId = section.id;
        };

        document.getElementById('btnCopyJson').onclick = async () => {
            try {
                await navigator.clipboard.writeText(JSON.stringify(store.toJSON(), null, 2));
                toast('JSON copied ✓');
            } catch {
                toast('Clipboard not available', true);
            }
        };

        document.getElementById('btnDownload').onclick = () => {
            const data = JSON.stringify(store.toJSON(), null, 2);
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([data], { type: 'application/json' }));
            a.download = `${store.getState().code || 'survey'}_designer.json`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 2000);
            toast('JSON downloaded');
        };

        surveyTitleInput.addEventListener('input', () => store.setMeta({ title: surveyTitleInput.value }));
        surveyCodeInput.addEventListener('input', () => store.setMeta({ code: surveyCodeInput.value.trim() }));

        async function importFromApi() {
            const code = surveyCodeInput.value.trim();
            if (!code) { toast('Enter a survey code to import', true); return; }
            try {
                const res = await appApiFetch(`/api/admin/surveys/${encodeURIComponent(code)}/definition`, {
                    headers: authHeaders
                });
                if (!res.ok) throw new Error('Failed');
                const def = await res.json();
                loadDefinition(def);
                toast('Definition imported');
            } catch {
                toast('Unable to fetch definition', true);
            }
        }

        async function exportToApi() {
            const code = surveyCodeInput.value.trim();
            if (!code) { toast('Survey code required to save', true); return; }
            const payload = store.toJSON();
            payload.code = code;
            payload.title = store.getState().title || payload.title || code;
            try {
                const saveDefinition = () => appApiFetch(`/api/admin/surveys/${encodeURIComponent(code)}/definition`, {
                    method: 'PUT',
                    headers: Object.assign({ 'Content-Type': 'application/json' }, authHeaders),
                    body: JSON.stringify(payload)
                });

                let res = await saveDefinition();

                if (res.status === 404) {
                    const createRes = await appApiFetch('/api/admin/surveys', {
                        method: 'POST',
                        headers: Object.assign({ 'Content-Type': 'application/json' }, authHeaders),
                        body: JSON.stringify({
                            code,
                            title: payload.title,
                            description: payload.description ?? null
                        })
                    });

                    if (!createRes.ok) {
                        throw new Error('Failed to create survey');
                    }

                    res = await saveDefinition();
                }

                if (!res.ok) throw new Error('Failed');
                toast('Survey saved to API ✓');
            } catch {
                toast('Failed to save survey', true);
            }
        }

        document.getElementById('btnImport').onclick = importFromApi;
        document.getElementById('btnExport').onclick = exportToApi;

        function loadDefinition(definition) {
            const sectionsRaw = definition.sections ?? definition.Sections ?? [];
            const optionsRaw = definition.options ?? definition.Options ?? [];
            const questionsRaw = definition.questions ?? definition.Questions ?? [];
            const rulesRaw = definition.rules ?? definition.Rules ?? [];
            const themeRaw = definition.theme ?? definition.Theme;

            const optionMap = new Map();
            optionsRaw.forEach(opt => {
                const questionId = opt.questionId ?? opt.QuestionId;
                if (!optionMap.has(questionId)) optionMap.set(questionId, []);
                optionMap.get(questionId).push({
                    id: opt.id ?? opt.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                    value: opt.value ?? opt.Value,
                    label: opt.label ?? opt.Label
                });
            });

            const sections = sectionsRaw.map((sec, idx) => ({
                id: sec.id ?? sec.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                title: sec.title ?? sec.Title ?? `Section ${idx + 1}`,
                order: sec.order ?? sec.Order ?? idx + 1,
                columns: sec.columns ?? sec.Columns ?? 1
            }));

            const questions = questionsRaw.map((q, idx) => {
                let parsedSettings = {};
                const rawJson = q.settingsJson ?? q.SettingsJson;
                if (rawJson) {
                    try { parsedSettings = JSON.parse(rawJson); } catch { parsedSettings = {}; }
                }
                const choices = optionMap.get(q.id ?? q.Id) ?? (parsedSettings.choices || []);
                const cleanedSettings = { ...parsedSettings };
                delete cleanedSettings.choices;
                const validations = Array.isArray(parsedSettings.validations) ? parsedSettings.validations : [];
                delete cleanedSettings.validations;
                const visibilityFromSettings = typeof parsedSettings.visibility === 'string' ? parsedSettings.visibility : '';
                delete cleanedSettings.visibility;
                const visibleIfFromDto = typeof (q.visibleIf ?? q.VisibleIf) === 'string' ? (q.visibleIf ?? q.VisibleIf) : '';
                const visibleIf = visibleIfFromDto || visibilityFromSettings;
                return {
                    id: q.id ?? q.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                    sectionId: q.sectionId ?? q.SectionId ?? null,
                    type: q.type ?? q.Type ?? 'text',
                    prompt: q.prompt ?? q.Prompt ?? 'Question',
                    key: q.key ?? q.Key ?? `question_${idx + 1}`,
                    required: q.required ?? q.Required ?? false,
                    order: q.order ?? q.Order ?? idx + 1,
                    settings: cleanedSettings,
                    choices: choices.map((opt, ci) => ({
                        id: opt.id ?? opt.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                        value: opt.value ?? opt.Value ?? `choice_${ci + 1}`,
                        label: opt.label ?? opt.Label ?? `Choice ${ci + 1}`
                    })),
                    validations,
                    visibleIf
                };
            });

            const rules = rulesRaw.map(rule => ({
                id: rule.id ?? rule.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                sourceQuestionId: rule.sourceQuestionId ?? rule.SourceQuestionId,
                condition: rule.condition ?? rule.Condition,
                action: rule.action ?? rule.Action
            }));

            store.load({
                code: definition.code ?? definition.Code ?? surveyCodeInput.value.trim(),
                title: definition.title ?? definition.Title ?? surveyTitleInput.value,
                sections,
                questions,
                rules,
                theme: themeRaw ? { accent: themeRaw.accent ?? themeRaw.Accent, panel: themeRaw.panel ?? themeRaw.Panel } : undefined
            });
        }

        // Boot with a default section for convenience
        if (store.getState().sections.length === 0) {
            store.addSection('Welcome');
        }
    </script>
</body>
</html>
