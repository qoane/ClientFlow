<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ClientFlow – Survey Designer</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #121936;
            --panel2: #0f1530;
            --muted: #9fb0ff;
            --text: #eef1ff;
            --accent: #6cf0c2;
            --accent2: #89b4ff;
            --danger: #ff6b6b;
            --border: rgba(255,255,255,.08);
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 800px at 80% -10%, #1b2550 0%, transparent 60%), var(--bg);
            color: var(--text);
            font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto;
        }

        .app {
            display: grid;
            grid-template-rows: 72px 1fr;
            min-height: 100vh;
        }

        header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg,#141c3f,#0e1533);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .logo {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: conic-gradient(from 210deg, var(--accent), var(--accent2));
            box-shadow: 0 0 0 2px rgba(255,255,255,.07) inset;
        }

        .tag {
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            color: #b9c6ff;
            font-size: 12px;
        }

        .toolbar {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .field label {
            font-size: 12px;
            color: var(--muted);
        }

        input, textarea, select {
            background: var(--panel2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            color: var(--text);
            font: inherit;
        }

        input:focus, textarea:focus, select:focus {
            outline: 2px solid rgba(108,240,194,.4);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: linear-gradient(180deg,#1a2248,#141c3f);
            color: #e9eeff;
            cursor: pointer;
            user-select: none;
            transition: transform .12s ease;
        }

        .btn:hover { transform: translateY(-1px); }
        .btn:disabled { opacity: .6; cursor: not-allowed; }
        .btn.ghost { background: transparent; }
        .btn.accent {
            background: linear-gradient(180deg,#19cba0,#0dbb93);
            color: #031b15;
            border: none;
        }
        .btn.danger {
            background: linear-gradient(180deg,#ef4444,#dc2626);
            color: #fff;
            border: none;
        }

        .shell {
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            gap: 14px;
            padding: 16px;
        }

        @media (max-width:1180px) {
            .shell {
                grid-template-columns: 220px 1fr;
                grid-template-areas:
                    "left main"
                    "left side";
            }
            .properties {
                grid-column: 1 / -1;
            }
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,.18);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel .head {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .panel .body {
            padding: 14px 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .tools {
            display: grid;
            gap: 10px;
        }

        .tool {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            background: linear-gradient(180deg,#1a2248,#141c3f);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .tool strong { font-size: 14px; }
        .tool small { color: rgba(203,214,255,.8); font-size: 12px; }

        .canvas {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .canvas-section {
            background: var(--panel);
            border: 1px solid rgba(255,255,255,.06);
            border-radius: 14px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,.15);
        }

        .canvas-section.selected {
            border-color: rgba(108,240,194,.6);
            box-shadow: 0 0 0 2px rgba(108,240,194,.25);
        }

        .section-meta {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-meta h3 {
            margin: 0;
            font-size: 16px;
        }

        .section-meta .actions {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }

        .question-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .question-card {
            border: 1px solid rgba(255,255,255,.05);
            border-radius: 12px;
            padding: 10px 12px;
            background: var(--panel2);
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            cursor: grab;
        }

        .question-card.selected {
            border-color: rgba(108,240,194,.6);
            box-shadow: 0 0 0 2px rgba(108,240,194,.25);
        }

        .question-card small { color: var(--muted); font-size: 12px; }

        .question-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .drop-slot {
            height: 10px;
            border-radius: 6px;
            border: 1px dashed transparent;
        }

        .drop-slot.active {
            border-color: rgba(108,240,194,.6);
            background: rgba(108,240,194,.18);
        }

        .properties .body label {
            font-size: 12px;
            color: var(--muted);
        }

        .properties .body .row {
            display: grid;
            gap: 6px;
        }

        .properties textarea {
            min-height: 90px;
            resize: vertical;
        }

        .switch {
            position: relative;
            width: 40px;
            height: 22px;
            display: inline-block;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,.2);
            transition: .2s;
            border-radius: 999px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            top: 3px;
            background: #0b1020;
            transition: .2s;
            border-radius: 50%;
        }
        .switch input:checked + .slider {
            background: rgba(108,240,194,.6);
        }
        .switch input:checked + .slider:before {
            transform: translateX(16px);
        }

        pre {
            background: var(--panel2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            color: #cfe0ff;
            overflow: auto;
            max-height: 260px;
        }

        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(15,21,48,.95);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,.35);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .toast.error {
            border-color: rgba(255,107,107,.5);
            color: #ffbaba;
        }

        .empty-state {
            padding: 40px 0;
            text-align: center;
            color: var(--muted);
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="brand">
                <div class="logo"></div>
                ClientFlow — <span>Survey Designer</span>
                <span class="tag">Drag &amp; Drop</span>
            </div>
            <div class="field">
                <label for="surveyCode">Survey Code</label>
                <input id="surveyCode" placeholder="liberty-nps" spellcheck="false" />
            </div>
            <div class="field">
                <label for="surveyTitle">Title</label>
                <input id="surveyTitle" placeholder="Liberty NPS 2025" />
            </div>
            <div class="toolbar">
                <button class="btn ghost" id="btnImport">Import JSON</button>
                <button class="btn" id="btnDownload">Download JSON</button>
                <button class="btn accent" id="btnExport">Save to API</button>
            </div>
        </header>

        <div class="shell">
            <aside class="panel" aria-label="Toolbox">
                <div class="head"><strong>Question Types</strong></div>
                <div class="body tools" id="toolbox"></div>
            </aside>

            <main class="canvas" id="canvas">
                <div class="panel" style="padding:0">
                    <div class="head" style="justify-content:space-between">
                        <div style="display:flex;align-items:center;gap:10px">
                            <strong>Survey Flow</strong>
                            <span class="tag" id="sectionCount">0 sections</span>
                        </div>
                        <button class="btn" id="btnAddSection">Add Section</button>
                    </div>
                    <div class="body" id="canvasSections"></div>
                </div>

                <div class="panel">
                    <div class="head" style="justify-content:space-between">
                        <strong>Normalized JSON</strong>
                        <button class="btn ghost" id="btnCopyJson">Copy</button>
                    </div>
                    <div class="body">
                        <pre id="jsonOutput">{}</pre>
                    </div>
                </div>
            </main>

            <aside class="panel properties" aria-label="Properties">
                <div class="head"><strong>Properties</strong></div>
                <div class="body" id="properties"></div>
            </aside>
        </div>
    </div>

    <script type="module">
        import { SurveyDesignerStore } from './survey-designer-store.js';

        const store = new SurveyDesignerStore();
        const toolbox = document.getElementById('toolbox');
        const canvasSections = document.getElementById('canvasSections');
        const sectionCount = document.getElementById('sectionCount');
        const properties = document.getElementById('properties');
        const jsonOutput = document.getElementById('jsonOutput');
        const surveyCodeInput = document.getElementById('surveyCode');
        const surveyTitleInput = document.getElementById('surveyTitle');

        let selectedSectionId = null;
        let selectedQuestionId = null;
        let draggingQuestionId = null;

        const palette = [
            { type: 'nps', label: 'NPS 0–10', hint: 'Detractors to promoters scale' },
            { type: 'likert', label: 'Likert 1–5', hint: 'Agreement scale' },
            { type: 'single', label: 'Single Select', hint: 'Radio buttons' },
            { type: 'multi', label: 'Multi Select', hint: 'Checkbox list' },
            { type: 'text', label: 'Free Text', hint: 'Short answer' },
            { type: 'phone', label: 'Phone', hint: '+266 …' },
            { type: 'number', label: 'Numeric', hint: 'Quantitative input' },
            { type: 'date', label: 'Date', hint: 'Calendar picker' },
            { type: 'boolean', label: 'Yes / No', hint: 'Binary choice' }
        ];

        function toast(message, isError = false) {
            const node = document.createElement('div');
            node.className = 'toast' + (isError ? ' error' : '');
            node.textContent = message;
            document.body.appendChild(node);
            setTimeout(() => node.remove(), 2600);
        }

        function ensureSelection(state) {
            if (!state.sections.some(sec => sec.id === selectedSectionId)) {
                selectedSectionId = state.sections[0]?.id ?? null;
            }
            if (!state.questions.some(q => q.id === selectedQuestionId)) {
                selectedQuestionId = null;
            }
        }

        function renderToolbox() {
            toolbox.innerHTML = '';
            palette.forEach(tool => {
                const card = document.createElement('div');
                card.className = 'tool';
                card.innerHTML = `<strong>${tool.label}</strong><small>${tool.hint}</small>`;
                card.onclick = () => addQuestion(tool.type);
                toolbox.appendChild(card);
            });
        }

        function addQuestion(type) {
            const state = store.getState();
            let targetSection = selectedSectionId;
            if (!targetSection) {
                const first = state.sections[0];
                if (first) {
                    targetSection = first.id;
                } else {
                    targetSection = store.addSection('Section 1').id;
                }
            }
            const question = store.addQuestion(targetSection, type);
            selectedSectionId = targetSection;
            selectedQuestionId = question.id;
        }

        function renderCanvas(state) {
            sectionCount.textContent = `${state.sections.length} section${state.sections.length === 1 ? '' : 's'}`;
            canvasSections.innerHTML = '';
            if (state.sections.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.innerHTML = 'No sections yet. Add one to start designing.';
                canvasSections.appendChild(empty);
                return;
            }

            state.sections.forEach((section, sectionIndex) => {
                const secEl = document.createElement('div');
                secEl.className = 'canvas-section';
                secEl.dataset.sectionId = section.id;
                if (section.id === selectedSectionId) secEl.classList.add('selected');
                secEl.onclick = (ev) => {
                    if (ev.target.closest('button')) return;
                    selectedSectionId = section.id;
                    selectedQuestionId = null;
                    renderProperties(store.getState());
                    highlightSelection();
                };

                const meta = document.createElement('div');
                meta.className = 'section-meta';

                const titleInput = document.createElement('input');
                titleInput.value = section.title;
                titleInput.onchange = () => store.updateSection(section.id, { title: titleInput.value });
                titleInput.onfocus = () => { selectedSectionId = section.id; highlightSelection(); };
                titleInput.style.minWidth = '180px';
                meta.appendChild(titleInput);

                const sectionLabel = document.createElement('span');
                sectionLabel.className = 'tag';
                sectionLabel.textContent = `Order ${section.order}`;
                meta.appendChild(sectionLabel);

                const actions = document.createElement('div');
                actions.className = 'actions';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn ghost';
                removeBtn.textContent = 'Delete';
                removeBtn.onclick = (ev) => {
                    ev.stopPropagation();
                    if (!confirm('Delete this section? Questions will be removed.')) return;
                    store.deleteSection(section.id);
                };
                actions.appendChild(removeBtn);

                if (sectionIndex > 0) {
                    const upBtn = document.createElement('button');
                    upBtn.className = 'btn ghost';
                    upBtn.textContent = '↑';
                    upBtn.onclick = (ev) => { ev.stopPropagation(); store.moveSection(section.id, sectionIndex - 1); };
                    actions.appendChild(upBtn);
                }
                if (sectionIndex < state.sections.length - 1) {
                    const downBtn = document.createElement('button');
                    downBtn.className = 'btn ghost';
                    downBtn.textContent = '↓';
                    downBtn.onclick = (ev) => { ev.stopPropagation(); store.moveSection(section.id, sectionIndex + 1); };
                    actions.appendChild(downBtn);
                }

                meta.appendChild(actions);
                secEl.appendChild(meta);

                const list = document.createElement('div');
                list.className = 'question-list';
                list.dataset.sectionId = section.id;

                const questions = state.questions
                    .filter(q => (q.sectionId ?? null) === section.id)
                    .sort((a, b) => a.order - b.order);

                for (let i = 0; i <= questions.length; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'drop-slot';
                    drop.dataset.index = i;
                    drop.addEventListener('dragover', ev => { ev.preventDefault(); drop.classList.add('active'); });
                    drop.addEventListener('dragleave', () => drop.classList.remove('active'));
                    drop.addEventListener('drop', ev => {
                        ev.preventDefault();
                        drop.classList.remove('active');
                        if (draggingQuestionId) {
                            store.moveQuestion(draggingQuestionId, section.id, Number(drop.dataset.index));
                        }
                    });
                    list.appendChild(drop);

                    if (i < questions.length) {
                        const question = questions[i];
                        const card = document.createElement('div');
                        card.className = 'question-card';
                        card.dataset.questionId = question.id;
                        card.draggable = true;
                        if (question.id === selectedQuestionId) card.classList.add('selected');
                        card.addEventListener('dragstart', () => { draggingQuestionId = question.id; });
                        card.addEventListener('dragend', () => { draggingQuestionId = null; });
                        card.onclick = (ev) => {
                            if (ev.target.closest('button')) return;
                            selectedQuestionId = question.id;
                            selectedSectionId = section.id;
                            renderProperties(store.getState());
                            highlightSelection();
                        };

                        const info = document.createElement('div');
                        const title = document.createElement('div');
                        title.textContent = question.prompt || 'Untitled question';
                        const metaLine = document.createElement('small');
                        metaLine.textContent = `${question.type.toUpperCase()} • ${question.key}`;
                        info.appendChild(title);
                        info.appendChild(metaLine);

                        const qActions = document.createElement('div');
                        qActions.className = 'question-actions';
                        const reqTag = document.createElement('span');
                        reqTag.className = 'tag';
                        reqTag.textContent = question.required ? 'Required' : 'Optional';
                        reqTag.style.background = question.required ? 'rgba(108,240,194,.12)' : 'rgba(159,176,255,.12)';
                        qActions.appendChild(reqTag);

                        const delBtn = document.createElement('button');
                        delBtn.className = 'btn ghost';
                        delBtn.textContent = 'Delete';
                        delBtn.onclick = (ev) => { ev.stopPropagation(); store.deleteQuestion(question.id); };
                        qActions.appendChild(delBtn);

                        card.appendChild(info);
                        card.appendChild(qActions);
                        list.appendChild(card);
                    }
                }

                const addAnother = document.createElement('button');
                addAnother.className = 'btn ghost';
                addAnother.textContent = 'Add question here';
                addAnother.onclick = (ev) => { ev.stopPropagation(); selectedSectionId = section.id; addQuestion('text'); };
                list.appendChild(addAnother);

                secEl.appendChild(list);
                canvasSections.appendChild(secEl);
            });
        }

        function highlightSelection() {
            document.querySelectorAll('.canvas-section').forEach(section => section.classList.remove('selected'));
            document.querySelectorAll('.question-card').forEach(card => card.classList.remove('selected'));
            if (selectedSectionId) {
                const container = document.querySelector(`.canvas-section[data-section-id="${selectedSectionId}"]`);
                if (container) container.classList.add('selected');
            }
            if (selectedQuestionId) {
                const card = document.querySelector(`.question-card[data-question-id="${selectedQuestionId}"]`);
                if (card) card.classList.add('selected');
            }
        }

        function renderProperties(state) {
            properties.innerHTML = '';
            if (!selectedQuestionId) {
                const hint = document.createElement('div');
                hint.className = 'empty-state';
                hint.innerHTML = 'Select a question to edit its properties.';
                properties.appendChild(hint);
                return;
            }

            const question = state.questions.find(q => q.id === selectedQuestionId);
            if (!question) {
                selectedQuestionId = null;
                renderProperties(state);
                return;
            }

            const makeRow = (label, control) => {
                const row = document.createElement('div');
                row.className = 'row';
                const lab = document.createElement('label');
                lab.textContent = label;
                row.appendChild(lab);
                row.appendChild(control);
                return row;
            };

            const promptInput = document.createElement('textarea');
            promptInput.value = question.prompt;
            promptInput.oninput = () => store.updateQuestion(question.id, { prompt: promptInput.value });
            properties.appendChild(makeRow('Prompt', promptInput));

            const keyInput = document.createElement('input');
            keyInput.value = question.key;
            keyInput.onchange = () => store.updateQuestion(question.id, { key: keyInput.value.trim() });
            properties.appendChild(makeRow('Key', keyInput));

            const requiredToggle = document.createElement('label');
            requiredToggle.className = 'switch';
            const reqInput = document.createElement('input');
            reqInput.type = 'checkbox';
            reqInput.checked = !!question.required;
            reqInput.onchange = () => store.updateQuestion(question.id, { required: reqInput.checked });
            const slider = document.createElement('span'); slider.className = 'slider';
            requiredToggle.appendChild(reqInput); requiredToggle.appendChild(slider);
            properties.appendChild(makeRow('Required', requiredToggle));

            if (['nps','likert','single','multi','boolean'].includes(question.type)) {
                const choicesArea = document.createElement('textarea');
                choicesArea.placeholder = 'value|Label';
                choicesArea.value = question.choices.map(choice => `${choice.value}|${choice.label}`).join('\n');
                choicesArea.onchange = () => {
                    const lines = choicesArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                    const mapped = lines.map((line, idx) => {
                        const [valuePart, labelPart] = line.includes('|') ? line.split('|') : [line, line];
                        const value = (valuePart || '').trim();
                        const label = (labelPart || valuePart || '').trim();
                        const existing = question.choices[idx];
                        return {
                            id: existing?.id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                            value: value || label || `choice_${idx + 1}`,
                            label: label || value || `Choice ${idx + 1}`
                        };
                    });
                    store.updateQuestion(question.id, { choices: mapped });
                };
                properties.appendChild(makeRow('Choices', choicesArea));
            }

            const validationsArea = document.createElement('textarea');
            validationsArea.placeholder = 'One validation per line (e.g. min:1)';
            validationsArea.value = (question.validations || []).join('\n');
            validationsArea.onchange = () => {
                const items = validationsArea.value.split('\n').map(x => x.trim()).filter(Boolean);
                store.updateQuestion(question.id, { validations: items });
            };
            properties.appendChild(makeRow('Validations', validationsArea));

            const visibleIfInput = document.createElement('input');
            visibleIfInput.placeholder = "e.g. status = 'active'";
            visibleIfInput.value = question.visibleIf || '';
            visibleIfInput.onchange = () => store.updateQuestion(question.id, { visibleIf: visibleIfInput.value.trim() });
            properties.appendChild(makeRow('Visible If', visibleIfInput));
        }

        function renderJson() {
            jsonOutput.textContent = JSON.stringify(store.toJSON(), null, 2);
        }

        renderToolbox();

        store.subscribe(state => {
            ensureSelection(state);
            if (document.activeElement !== surveyTitleInput) surveyTitleInput.value = state.title ?? '';
            if (document.activeElement !== surveyCodeInput) surveyCodeInput.value = state.code ?? '';
            renderCanvas(state);
            renderProperties(state);
            renderJson();
            highlightSelection();
        });

        document.getElementById('btnAddSection').onclick = () => {
            const section = store.addSection(`Section ${store.getState().sections.length + 1}`);
            selectedSectionId = section.id;
        };

        document.getElementById('btnCopyJson').onclick = async () => {
            try {
                await navigator.clipboard.writeText(JSON.stringify(store.toJSON(), null, 2));
                toast('JSON copied ✓');
            } catch {
                toast('Clipboard not available', true);
            }
        };

        document.getElementById('btnDownload').onclick = () => {
            const data = JSON.stringify(store.toJSON(), null, 2);
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([data], { type: 'application/json' }));
            a.download = `${store.getState().code || 'survey'}_designer.json`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 2000);
            toast('JSON downloaded');
        };

        surveyTitleInput.addEventListener('input', () => store.setMeta({ title: surveyTitleInput.value }));
        surveyCodeInput.addEventListener('input', () => store.setMeta({ code: surveyCodeInput.value.trim() }));

        async function importFromApi() {
            const code = surveyCodeInput.value.trim();
            if (!code) { toast('Enter a survey code to import', true); return; }
            try {
                const res = await fetch(`/api/admin/surveys/${encodeURIComponent(code)}/definition`);
                if (!res.ok) throw new Error('Failed');
                const def = await res.json();
                loadDefinition(def);
                toast('Definition imported');
            } catch {
                toast('Unable to fetch definition', true);
            }
        }

        async function exportToApi() {
            const code = surveyCodeInput.value.trim();
            if (!code) { toast('Survey code required to save', true); return; }
            const payload = store.toJSON();
            payload.code = code;
            payload.title = store.getState().title || payload.title || code;
            try {
                const res = await fetch(`/api/admin/surveys/${encodeURIComponent(code)}/definition`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error('Failed');
                toast('Survey saved to API ✓');
            } catch {
                toast('Failed to save survey', true);
            }
        }

        document.getElementById('btnImport').onclick = importFromApi;
        document.getElementById('btnExport').onclick = exportToApi;

        function loadDefinition(definition) {
            const sectionsRaw = definition.sections ?? definition.Sections ?? [];
            const optionsRaw = definition.options ?? definition.Options ?? [];
            const questionsRaw = definition.questions ?? definition.Questions ?? [];
            const rulesRaw = definition.rules ?? definition.Rules ?? [];
            const themeRaw = definition.theme ?? definition.Theme;

            const optionMap = new Map();
            optionsRaw.forEach(opt => {
                const questionId = opt.questionId ?? opt.QuestionId;
                if (!optionMap.has(questionId)) optionMap.set(questionId, []);
                optionMap.get(questionId).push({
                    id: opt.id ?? opt.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                    value: opt.value ?? opt.Value,
                    label: opt.label ?? opt.Label
                });
            });

            const sections = sectionsRaw.map((sec, idx) => ({
                id: sec.id ?? sec.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                title: sec.title ?? sec.Title ?? `Section ${idx + 1}`,
                order: sec.order ?? sec.Order ?? idx + 1,
                columns: sec.columns ?? sec.Columns ?? 1
            }));

            const questions = questionsRaw.map((q, idx) => {
                let parsedSettings = {};
                const rawJson = q.settingsJson ?? q.SettingsJson;
                if (rawJson) {
                    try { parsedSettings = JSON.parse(rawJson); } catch { parsedSettings = {}; }
                }
                const choices = optionMap.get(q.id ?? q.Id) ?? (parsedSettings.choices || []);
                const cleanedSettings = { ...parsedSettings };
                delete cleanedSettings.choices;
                const validations = Array.isArray(parsedSettings.validations) ? parsedSettings.validations : [];
                delete cleanedSettings.validations;
                const visibilityFromSettings = typeof parsedSettings.visibility === 'string' ? parsedSettings.visibility : '';
                delete cleanedSettings.visibility;
                const visibleIfFromDto = typeof (q.visibleIf ?? q.VisibleIf) === 'string' ? (q.visibleIf ?? q.VisibleIf) : '';
                const visibleIf = visibleIfFromDto || visibilityFromSettings;
                return {
                    id: q.id ?? q.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                    sectionId: q.sectionId ?? q.SectionId ?? null,
                    type: q.type ?? q.Type ?? 'text',
                    prompt: q.prompt ?? q.Prompt ?? 'Question',
                    key: q.key ?? q.Key ?? `question_${idx + 1}`,
                    required: q.required ?? q.Required ?? false,
                    order: q.order ?? q.Order ?? idx + 1,
                    settings: cleanedSettings,
                    choices: choices.map((opt, ci) => ({
                        id: opt.id ?? opt.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                        value: opt.value ?? opt.Value ?? `choice_${ci + 1}`,
                        label: opt.label ?? opt.Label ?? `Choice ${ci + 1}`
                    })),
                    validations,
                    visibleIf
                };
            });

            const rules = rulesRaw.map(rule => ({
                id: rule.id ?? rule.Id ?? (crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)),
                sourceQuestionId: rule.sourceQuestionId ?? rule.SourceQuestionId,
                condition: rule.condition ?? rule.Condition,
                action: rule.action ?? rule.Action
            }));

            store.load({
                code: definition.code ?? definition.Code ?? surveyCodeInput.value.trim(),
                title: definition.title ?? definition.Title ?? surveyTitleInput.value,
                sections,
                questions,
                rules,
                theme: themeRaw ? { accent: themeRaw.accent ?? themeRaw.Accent, panel: themeRaw.panel ?? themeRaw.Panel } : undefined
            });
        }

        // Boot with a default section for convenience
        if (store.getState().sections.length === 0) {
            store.addSection('Welcome');
        }
    </script>
</body>
</html>
